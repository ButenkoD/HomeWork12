articles:
    1:
        title: First article in blog
        category: category1
        tag:
            - tag1
            - tag3
        viewsNumber: 3
        content: Validation is a very common task in web applications. Data entered in forms needs to be validated. Data also needs to be validated before it is written into a database or passed to a web service.
    2:
        title: Boris
        category: category3
        tag:
            - tag2
            - tag3
        viewsNumber: 7
        content: In YAML, the special @my_mailer syntax tells the container to look for a service named my_mailer and to pass that object into the constructor of NewsletterManager. In this case, however, the specified service my_mailer must exist. If it does not, an exception will be thrown. You can mark your dependencies as optional - this will be discussed in the next section.              Using references is a very powerful tool that allows you to create independent service classes with well-defined dependencies. In this example, the newsletter_manager service needs the my_mailer service in order to function. When you define this dependency in the service container, the container takes care of all the work of instantiating the classes.
    3:
        title: Foo
        category: category0
        tag:
            - tag0
            - tag3
        viewsNumber: 5
        content: In YAML, the special @my_mailer syntax tells the container to look for a service named my_mailer and to pass that object into the constructor of NewsletterManager. In this case, however, the specified service my_mailer must exist. If it does not, an exception will be thrown. You can mark your dependencies as optional - this will be discussed in the next section.              Using references is a very powerful tool that allows you to create independent service classes with well-defined dependencies. In this example, the newsletter_manager service needs the my_mailer service in order to function. When you define this dependency in the service container, the container takes care of all the work of instantiating the classes.
    4:
        title: FooFoo
        category: category2
        tag:
            - tag2
            - tag3
        viewsNumber: 2
        content: If you choose to, you can also integrate the file upload into your entity lifecycle (i.e. creation, update and removal). In this case, as your entity is created, updated, and removed from Doctrine, the file uploading and removal processing will take place automatically (without needing to do anything in your controller).
    5:
        title: Bar
        category: category3
        tag:
            - tag3
        viewsNumber: 9
        content: Injecting dependencies into the constructor in this manner is an excellent way of ensuring that the dependency is available to use. If you have optional dependencies for a class, then "setter injection" may be a better option. This means injecting the dependency using a method call rather than through the constructor. The class would look like this:
    6:
        title: BarBar
        category: category3
        tag:
            - tag2
            - tag3
        viewsNumber: 1
        content: The service container also supports an "expression" that allows you to inject very specific values into a service.              For example, suppose you have a third service (not shown here), called mailer_configuration, which has a getMailerMethod() method on it, which will return a string like sendmail based on some configuration. Remember that the first argument to the my_mailer service is the simple string sendmail:              But instead of hardcoding this, how could we get this value from the getMailerMethod() of the new mailer_configuration service? One way is to use an expression: